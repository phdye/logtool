#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Usage:  logts [options] <command> [ <argv> ... ]

  Log the output of <command> to <base>/<date>/<time>.txt
  and also pipe its output to STDOUT.

Options:

  -b <base>, --base <base>  MANDATORY - fatal error if not specified.
                  Place dated log directories under <base>.
                    * dirname(<base>) must exist
                    * basename(<base>) will be created if necessary
                    * <base>/<date> will be created if necessary
                    * output to <base>/<date>/<time>.txt

  -c, --clean     [DEFAULT = True] -- actually, always forced True.
                  Create time directory level to hold raw (vt102, ANSI,
                  color, etc) and clean (simply text) output.
                    * <base>/<date>/<time> will be created
                    * raw output to <base>/<date>/<time>/raw.dat
                    * clean text to <base>/<date>/<time>/out.txt
                      !!! clean text not implemented yet
                      !!! will probably use raw-to-text equivalent

  -p <p>, --prefix
                  Prefix the log file with file string <p>.

  --ts <ts>       Use <ts> for the timestamp.  Useful to link multiple
                  stages of a process by an overall starting timestamp.

  --ref <file>    As with '--ts', but use <file>'s last modification
                  time for timestamp and '--ref' superceeds '--ts'.

  -v, --verbose   Print a bit more detail about the actions being taken.
                  - Superceeded by '--quiet'

  -q, --quiet     Print less, keep quiet.
                  - Superceeds '--verbose' -- turns verbose off.
                  - Superceeded by '--debug'

  -d, --debug     Show debugging details.
                  - Superceeds '--quiet'
                  - Implies '--verbose'

  -n, --no-show   Do not print or log the command line.

  -a, --append    If the target log file already exists, append to it
                  -- applicable when '--ts' or '--ref' are specified.

  --help          Print this usage informatsion to STDERR and exit.

  --version       Print program version to STDERR and exit.

NOT IMPLEMENTED YET :

  -s, --silent    Print nothing unless an error occurs.

"""

#-------------------------------------------------------------------:----------

from __future__ import print_function

import sys
import os

from docopt import docopt

from time import localtime, strftime

import dateparser


from logtool import log

from plumbum import local, FG

from pprint import PrettyPrinter
pp = PrettyPrinter(indent=4).pprint
pp8 = PrettyPrinter(indent=8).pprint

#------------------------------------------------------------------------------

DATE_FORMAT = "%Y-%m-%d"
TIME_FORMAT = "%H-%M-%S"
                
#------------------------------------------------------------------------------

# As setuptools' entry point passes nothing, argv must default to sys.argv main
# to work.  Do not use sys.argv inside main since that would break unit tests.

def main ( argv = sys.argv ) :

    return perform ( configure ( parse_arguments ( argv[1:] ) ) )

#------------------------------------------------------------------------------

def perform ( cfg ) :

    command_line  = ' '.join( [ cfg.command ] + cfg.argv )

    if not cfg.quiet :
        print ( '' )
        print ( "+ " + command_line )
        print ( '' )
        with open ( cfg.log_file, cfg.mode ) as f :
            print ( '+ ' + command_line, file = f )
            print ( '', file = f )
        sys.stdout.flush()

    # log <log-file> <command> ...

    xfg = log.ActionConfig()
    xfg.debug = cfg.debug
    xfg.verbose = cfg.verbose
    xfg.quiet = cfg.quiet
    xfg.show = cfg.show
    xfg.logDir = cfg.log_dir
    xfg.logfile = cfg.log_file
    xfg.mode = 'w' if cfg.quiet else 'a'
    xfg.command = cfg.command
    xfg.argv = cfg.argv
    
    xfg.show = False # FIXME: why this forced setting ?

    try :
        retcode = log.perform ( xfg )
        if xfg.debug :
            print ( '' )
            print('log:  retcode = {} (as received by logts)'.format(str(retcode)))
        arrange_the_log_files(cfg)
        return retcode
    except Exception as e :
        if xfg.debug :
            print('logts:  RAISE : retcode = ?')
        print ( '' )
        arrange_the_log_files(cfg)
        raise e

#------------------------------------------------------------------------------

def arrange_the_log_files ( cfg ) :
    
    if not os.path.exists ( cfg.log_file ) :
        return False

    link_name = 'latest.txt'

    if cfg.clean and cfg.raw_name is not None :
        
        # log-dir : raw-to-text < %raw_file% > %text_file%
        
        raw_file = cfg.log_file
        cfg.log_file = os.path.join ( cfg.log_dir, cfg.text_name )
        rawtotext = local['raw-to-text']
        # ((grep["world"] < sys.stdin) > "tmp.txt")()
        ( ( rawtotext[""] < raw_file ) > cfg.log_file )()
        if not os.path.exists ( cfg.log_file ) :
            raise ValueError("raw to text conversion failed.  Text-only log " +
                                 "'%s' does not exist." % ( cfg.log_file ))
        # Script done, file is log/build/2019-03-30/02-28-52/raw.dat
        # ....... text file is log/build/2019-03-30/02-28-52/out.txt
        if not cfg.quiet :
            print("And the text file is %s" % ( cfg.log_file ))
        
        # date-dir : <d>/latest.txt -> <time>/out.txt

        symlink = os.path.join ( cfg.log_date_dir, link_name )
        if os.path.lexists ( symlink ) :
            os.unlink ( symlink )
        os.symlink ( os.path.join ( cfg.time_string, cfg.text_name ), symlink )
        if cfg.verbose :
            print ( ". created symlink '{}'".format(symlink) )

    else :
        
        # log-dir  ; nothing, it does not exist
        # date-dir : <d>/latest.txt -> <time>.txt
        symlink = os.path.join ( cfg.log_date_dir, link_name )
        if os.path.lexists ( symlink ) :
            os.unlink ( symlink )
        os.symlink ( os.path.join ( cfg.time_string, cfg.raw_name ), symlink )
        if cfg.verbose :
            print ( ". created symlink '{}'".format(symlink) )

    # log-base : <b>/latest.txt -> <date>/latest.txt
        
    symlink = os.path.join ( cfg.log_base, link_name )        
    if os.path.lexists ( symlink ) :
        os.unlink ( symlink )
    os.symlink ( os.path.join ( cfg.date_string, link_name), symlink )
    if not cfg.quiet :
        print ( ". created symlink '{}'".format(symlink) )
        print('')

#------------------------------------------------------------------------------

class ActionConfig ( object ) :
    __slots__ = ( 'log_base', 'log_date_dir', 'log_dir', 'log_name', 'log_file'
                  , 'log_prefix', 'append', 'mode', 'date_string', 'time_string'
                  , 'time_stamp', 'command', 'argv', 'debug', 'quiet', 'verbose'
                  , 'show', 'clean', 'raw_name', 'text_name', )

    def __init__ ( self ) :
        self.log_base = None
        self.log_date_dir = None
        self.log_dir = None
        self.log_name = None
        self.log_file = None
        self.log_prefix = None
        self.mode = None
        self.date_string = None
        self.time_string = None
        self.time_stamp = None
        self.command = None
        self.argv = []
        self.debug = None
        self.quiet = None
        self.verbose = None
        self.show = None
        self.clean = None
        self.raw_name = None
        self.text_name = None
                          
#------------------------------------------------------------------------------

def configure ( args ) :

    cfg = ActionConfig()

    cfg.debug = args['--debug']

    # debug overrides quiet
    cfg.quiet = args['--quiet'] if not cfg.debug else False

    # quiet overrides verbose
    cfg.verbose = args['--verbose'] if not cfg.quiet else False

    cfg.show = not args['--no-show']
    
    cfg.log_base = args['--base']
    
    if not os.path.isdir ( os.path.dirname ( cfg.log_base ) ) :
        pass # error

    # set time_stamp
    if args['--ref'] is not None :
        ts = os.path.getmtime(args['--ref'])
    elif args['--ts'] is not None :
        ts = dateparser.parse(date_string=args['--ts'])
    else :
        ts = None
    cfg.time_stamp = localtime(ts)

    cfg.time_string = strftime ( TIME_FORMAT, cfg.time_stamp )

    cfg.log_prefix = args['--prefix'] if args['--prefix'] is not None else ''
    
    cfg.clean = args['--clean']
    # every lower level will be created if needed
    cfg.date_string = strftime ( DATE_FORMAT, cfg.time_stamp )
    cfg.log_dir = [ cfg.log_base, cfg.date_string ]
    cfg.log_date_dir = os.path.join ( * cfg.log_dir )
    if cfg.clean :
        cfg.log_dir = os.path.join ( cfg.log_date_dir, cfg.time_string )
        cfg.raw_name = cfg.log_prefix + 'raw.dat'
        cfg.text_name = cfg.log_prefix + 'out.txt'
        cfg.log_name = cfg.raw_name
        os.environ['LOGTS_LOG_DIR'] = cfg.log_dir
    else :
        cfg.log_dir = cfg.log_date_dir
        cfg.log_name = cfg.log_prefix + cfg.time_string + '.txt'

    os.makedirs ( cfg.log_dir, exist_ok=True )

    cfg.log_file = os.path.join ( cfg.log_dir, cfg.log_name )

    cfg.append = args['--append']

    cfg.mode = 'a' if cfg.append else 'w'

    cfg.command  = args['<command>']
    cfg.argv     = args['<argv>']
   
    return cfg

#------------------------------------------------------------------------------

def parse_arguments ( argv ) :

    if False : # not quiet and verbose : # '--verbose' in argv :
         print("+ [logts] '"+"' '".join(argv)+"'")

    args = docopt ( __doc__, argv, version=version, options_first=True )

    if args['--base'] is None :
        print('')
        print('Error: <base> missing.  Please specify a log file base directory.')
        print('')
        print('Usage:  logts [options] <command> [ <argv> ... ]')
        print('')
        exit ( 1 )

    if args['--debug'] :
        print("+ logts '"+"' '".join(argv)+"'")
        print('')
        print('parsed args :')
        pp(args)
        print('')

    args['--clean'] = True	# !!! always true for now

    return args

#------------------------------------------------------------------------------

if __name__ == '__main__':
    # exit ( main ( sys.argv ) )
    retcode = main ( sys.argv )
    print('logts:  retcode = {}'.format(str(retcode)))
    exit ( retcode )


#------------------------------------------------------------------------------
